GAMS 32.2.0  rc62c018 Released Aug 26, 2020 WEX-WEI x86 64bit/MS Windows - 10/07/21 16:00:27 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


      Bismark Singh
      March 17, 2021
       
      Code for plain Lagrangian decomposition (removed Progressive Hedging)
      Based on the paper at http://www.optimization-online.org/DB_HTML/2019/05/7222.html
       
       
      Excel file used for LB heuristic needs to be manually sorted
       
  12   
  14  OPTIONS PROFILE =3, RESLIM   = 4200, LIMROW   = 5, LP = CPLEX, MIP = cplex, RMIP=cplex, NLP = CONOPT, MINLP = DICOPT, MIQCP = CPLEX, SOLPRINT = OFF, decimals = 8, optcr=0.001, optca=0.001, threads =8, integer4=0;
  15   
  16  ********************************************************************************
  17  *                                Include input files
  18  ********************************************************************************
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
  20  ** sets later to be defined in input file
  21   
  22  ** to be changed
  23   
  24  SETS T times/t1*t24/;
  25  * Number of scenarios
  26  *SETS SCEN scenarios /scen1*%MAXSCEN%/;
  27  SETS SCEN scenarios /scen1*scen100/;
  28  alias(scen, w);
  29  Parameter last_z(scen);
  30   
  31  SCALAR G, GG, start_cost, ramp, uptime, downtime;
  32  G=130;
  33  GG=20;
  34  ramp=50;
  35  UPTIME =3;
  36  DOWNTIME=3;
  37   
  38  TABLE wind(scen,t)
  40  *$INCLUDE %SOLAR%.csv
  41  $INCLUDE wind_scenarios_600_1.csv
****                                  $282
**** LINE     22 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
**** LINE     19 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 282  Unable to open include file
  43  ;
****  $463
**** LINE     24 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
**** LINE     19 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 463  The column section in the previous table is missing.
****         You may want to use $ON/OFFEMPTY
  44  *alias(solar,wind);
  45   
  46  *Tolerance
  47  scalar tol;
  48  *tol=%TOL%;
  49  tol=0.05;
  50   
  51  * maximum number of iterations in LR
  52  set iter number of subgradient iterations /iter1*iter10/;
  53   
  54  * time limit for each problem
  55  scalar time_limit;
  56  *time_limit=%TIMELIM%;
  57  time_limit=2250;
  58   
  59   
  60  * Import the SORTED file
  61  table scenario_sorted(scen,*)
  63  $INCLUDE scenario_sorted.csv
****                             $282
**** LINE     44 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
**** LINE     19 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 282  Unable to open include file
  65  ;
****  $463
**** LINE     46 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
**** LINE     19 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 463  The column section in the previous table is missing.
****         You may want to use $ON/OFFEMPTY
  66   
  67   
  68   
  69   
  70   
  71  ALIAS (T,TT);
  72  alias(scen,i);
  73   
  74  scalar n;
  75  n=card(scen);
  76   
  77  *Scalar which tells if LR converges
  78  scalar convergence;
  79   
  80  ** define battery  operation costs costs and solar selling prices
  81   
  82  TABLE PRICES(t,*)
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\wind_costs.csv
  85  ,REW,GEN
  86  t1,21.86631793,50
  87  t2,22.68762551,50
  88  t3,22.63231186,50
  89  t4,23.53977501,50
  90  t5,24.15305477,50
  91  t6,25.0022415,50
  92  t7,26.14884331,50
  93  t8,28.48265662,50
  94  t9,35.32421651,50
  95  t10,53.07988113,50
  96  t11,67.07745747,50
  97  t12,43.78264533,50
  98  t13,33.25218533,50
  99  t14,28.68827035,50
 100  t15,26.76175663,50
 101  t16,23.97472252,50
 102  t17,21.05077606,50
 103  t18,18.8721276,50
 104  t19,17.16537812,50
 105  t20,15.4798614,50
 106  t21,14.81514842,50
 107  t22,14.64047737,50
 108  t23,15.10197375,50
 109  t24,17.32390701,50
 111  ;
 112  *alias(costs, prices);
 113   
 114  Prices(t,'rew')     =  - Prices(t,'rew');
 115  Prices(t,'gen')    =  - Prices(t,'gen');
 116  ** define solar scenarios at all time periods
 117   
 118   
 119  * Scaling of wind power scenarios ;
 120  scalar scale ;
 121  scale = 1;
 122  wind(scen,t) = scale* wind(scen,t) ;
 123  * Remove too many decimals in Solar
 124  wind(scen,t) = round(wind(scen,t),2) ;
 125   
 126   
 127  scalar PROBABILITY;
 128  PROBABILITY = 1/CARD(scen);
 129   
 130   
 131  parameters max_store(t), min_store(t), max_charge, max_discharge;
 132   
 133   
 134  ** define tolerance threshold
 135  SCALAR threshold;
 136  threshold = floor(card(scen)*TOL)  ;
 137   
      parameter BigX, LowX, X_0 maximum minimum initial energy stored ;
      parameter BigM(scen,t) find a good BigM ;
       
      BigX = 960 ;
      LowX = 0.2* BigX ;
      X_0  = 0.5* BigX ;
      max_charge =  0.5* BigX ;
      max_discharge =  0.5* BigX ;
 148   
 149  ************** Find a Big M
 150   
 151  * find Ntol + 1st value
 152  parameter maxwind(t), minwind(t), dummywind(w,t) ;
 153  maxwind(t) =smax(w,wind(w,t)) ;
 154  dummywind(w,t) = wind(w,t) ;
 155   
 156  scalar it ;
 157  it = floor(card(w)*tol) + 1;
 158   
 159  * index of it
 160  set dummy(w);
 161  * make the dum_iter go till at least the size of it
 162  set dum_iter /dum_iter1*dum_iter100/;
 163  loop(t,
 164  loop(dum_iter$(ord(dum_iter)le it),
 165  * find the smallest wind value for this t
 166           minwind(t) = smin(w,dummywind(w,t)) ;
 167  * index of smallest wind value
 168           dummy(w) = yes$(dummywind(w,t) eq minwind(t)) ;
 169  * make the smallest wind value large
 170           dummywind(w,t)$dummy(w) =maxwind(t) ;
 171  ); );
 172  display minwind ;
 173   
 174   
 175   
 176  parameter BigMM(w), BigM(w,t);
 177  BigMM(w)= smax(t, wind(w,t));
 178  BigM(w,t)= G - wind(w,t) + minwind(t);
 179   
 180   
 181  scalar run_time_total, start_time, end_time, LP_time, bound_time, lr_time ;
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\subgradient_parameters.gms
 183  parameter lambda;
 184  parameter ldual value of Lagrangian dual ;
 185  parameter bound total value of Lagrangian dual ;
 186  scalar init_lambda, init_bound initial value of lambda dual LP objective from LP ;
 187  *Hier werden die maximalen Iterationen, also big M festgelegt
 188  *set iter                 number of subgradient iterations /iter1*iter3/;
 189  scalar num_iter          how many iterations we did ;
 190  scalar contin            stopping             /1/;
 191  parameter stepsize;
 192  scalar theta /2/;
 193  scalar originalTheta;
 194  originalTheta=theta;
 195  scalar noimprovement /0/;
 196  scalar upperbound ;
 197  parameter gamma           subgradient          ;
 198  parameter b;
 199  parameter norm;
 200  parameter norm2;
 201  scalar lowerbound;
 202  parameter lambdaprevious, deltalambda, results(iter,*), prev_w(scen,t), prev_y(t)  ;
 203   
 204   
 205  scalar m ;
 206  parameter   y_previous(scen,t), y_average_previous(t), weight_previous(scen,t);
 207  scalar profit_orig, t1, t2, exit_tol;
 208   
 209  scalar final_gap ;
 210   
 211  parameter lb(scen) ;
 212  parameter rho(t) ;
 213   
 214  scalar exit_tol ;
 215  exit_tol = 0.00001 ;
 216   
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\equations_all.gms
 218  POSITIVE VARIABLES X(W,T), Y(T),U(W,T), V(W,T);
 219  VARIABLES OBJ, BOUND_LR;
 220  BINARY VARIABLE Z(SCEN), R(W,T) ;
 221   
 222  scalar counter ;
 223   
 224  EQUATIONS
 225          Objective
 226          Const1_1(scen,t)
 227          Const1_2
 228          Const_3_1(scen,t)
 229          Const_3_1_scenario(scen,t)
 230          Const_3_2(scen,t)
 231          Const_3_2_scenario(scen,t)
 232          Const_4_1(scen,t)
 233          Const_4_1_scenario(scen,t)
 234          Const_4_2(scen,t)
 235          Const_4_2_scenario(scen,t)
 236          Const_5(scen,t)
 237          Const_5_scenario(scen,t)
 238          Const_6(scen,t)
 239          Const_6_scenario(scen,t)
 240          LR
 241          Objective_scenario(scen)
 242          Const1_1_scenario(scen,t)
 243          ;
 244   
 245  Objective.. OBJ=E= SUM(T,PRICES(T, 'REW')*Y(T) - PROBABILITY*SUM(scen, PRICES(T, 'GEN')*( X(scen,T) + GG*R(scen,t) ) )  )  ;
 246   
 247  LR.. bound_lr =e=   SUM(T,PRICES(T, 'REW')*Y(T) - PROBABILITY*SUM(scen, PRICES(T, 'GEN')*( X(scen,T) + GG*R(scen,t) ) )  )
 248                           - lambda* (threshold - sum(scen, z(scen)))  ;
 249   
 250  Objective_scenario(scen)$(ord(scen) eq counter)..
 251           OBJ =E= SUM(TT,PRICES(tt, 'REW')*Y(TT) - PRICES(TT, 'GEN')*( X(scen,TT) + GG*R(scen,tt) ) )     ;
 252   
 253  *Const1_1(W,T).. Y(T)-X(W,T)-R(W,T)*GG -Z(W)*WIND(W,T) =L= (1-Z(W))*BigMM(w) ;
 254  Const1_1(scen,T).. Y(T)-X(scen,T)-R(scen,T)*GG -WIND(scen,T) =L= Z(scen)*BigM(scen,t) ;
 255   
 256  *Const1_1_scenario(scen,t)$(ord(t) lt card(t) and (ord(scen) eq counter))..
 257  Const1_1_scenario(scen,t)$(ord(scen) eq counter)..
 258   
 259           Y(T)-X(scen,T)-R(scen,T)*GG -WIND(scen,T) =L= 0 ;
 260   
 261  Const1_2..   -SUM(SCEN, Z(SCEN)) =G= -threshold;
 262   
 263  ****************************************************************************TODO Constraints (all but no. 1) in scenario form (z(w)=0)
 264   
 265  * The generator constraints
 266   
 267  *Ramp
 268   
 269  Const_3_1(scen,T)$( ord(t) le (card(t)-1)).. X(scen,T+1) + GG*R(scen,t+1)- X(scen,T) - GG*R(scen,t)  =L= ramp*(U(scen,t+1) + R(scen,t)) ;
 270  Const_3_1_scenario(scen,T)$( ord(t) le (card(t)-1) and (ord(scen) eq counter)).. X(scen,T+1) + GG*R(scen,t+1)- X(scen,T) - GG*R(scen,t)  =L= ramp*(U(scen,t+1) + R(scen,t)) ;
 271   
 272  Const_3_2(scen,T)$( ord(t) le (card(t)-1)).. X(scen,T) + GG*R(scen,t)- X(scen,T+1) -GG*R(scen,t+1)=L= ramp*(V(scen,t+1) + R(scen,t+1)) ;
 273  Const_3_2_scenario(scen,T)$( ord(t) le (card(t)-1) and (ord(scen) eq counter)).. X(scen,T) + GG*R(scen,t)- X(scen,T+1) -GG*R(scen,t+1)=L= ramp*(V(scen,t+1) + R(scen,t+1)) ;
 274   
 275  *On/off
 276   
 277  Const_4_1(scen,T)$(ord(t) ge uptime)..   Sum(tt$((ORD(TT) le ORD(T)) and (ORD(TT) ge (ORD(T) - UPTIME +1))),U(scen,TT)) =L= R(scen,T) ;
 278  Const_4_1_scenario(scen,T)$(ord(t) ge uptime and (ord(scen) eq counter))..   Sum(tt$((ORD(TT) le ORD(T)) and (ORD(TT) ge (ORD(T) - UPTIME +1))),U(scen,TT)) =L= R(scen,T) ;
 279   
 280  Const_4_2(scen,T)$(ord(t) ge downtime )..Sum(tt$((ORD(TT) le ORD(T)) and (ORD(TT) ge (ORD(T) - DOWNTIME +1))),V(scen,TT)) =L= 1-R(scen,T) ;
 281  Const_4_2_scenario(scen,T)$(ord(t) ge downtime and (ord(scen) eq counter))..Sum(tt$((ORD(TT) le ORD(T)) and (ORD(TT) ge (ORD(T) - DOWNTIME +1))),V(scen,TT)) =L= 1-R(scen,T) ;
 282   
 283  Const_5(scen,T)$(ord(t) ge 2).. U(scen,T) - V(scen,T) =E= R(scen,T) - R(scen,T-1) ;
 284  Const_5_scenario(scen,T)$(ord(t) ge 2 and (ord(scen) eq counter)).. U(scen,T) - V(scen,T) =E= R(scen,T) - R(scen,T-1) ;
 285   
 286  *if uptime more than 1
 287  Const_6(scen,T)$( ord(t) le (card(t)-1))..   (G-GG)*R(scen,T)- (G-ramp)*U(scen,T) - (G-ramp)*V(scen,T+1) =G= X(scen,T);
 288  Const_6_scenario(scen,T)$( ord(t) le (card(t)-1) and (ord(scen) eq counter))..   (G-GG)*R(scen,T)- (G-ramp)*U(scen,T) - (G-ramp)*V(scen,T+1) =G= X(scen,T);
 289   
 290   
 291  *** bounds on any variables
 292  X.UP(scen,T) =  G-GG;
 293  U.UP(scen,T) = 1;
 294  V.UP(scen,T) =1;
 295  Z.UP(scen)=1;
 296   
 297  * initialize the on/off variables
 298  * assume the unit was on for last (uptime -1) periods
 299  r.fx(scen,t)$(ord(t) eq 1) =1;
 300  u.fx(scen,t)$(ord(t) eq 1) = 0;
 301  v.fx(scen,t)$(ord(t) eq 1) = 0 ;
 302  * assume the generator was producing minimim power in last time period
 303  x.up(scen,t)$(ord(t) eq 1)= ramp - GG;
 304   
 305   
 306  ******* ALL MODELS
 307   
 308  model schedule     / Objective,  Const1_1, Const1_2, Const_3_1, Const_3_2, Const_4_1, Const_4_2, Const_5, Const_6 /;
 309  model schedule_scenario     / Objective_scenario,  Const1_1_scenario, Const_3_1_scenario, Const_3_2_scenario, Const_4_1_scenario, Const_4_2_scenario, Const_5_scenario, Const_6_scenario / ;
 310  *model INITIAL               / / ;
 311  model Lagrangian      / LR,    Const1_1, Const_3_1, Const_3_2, Const_4_1, Const_4_2, Const_5, Const_6 /;
 312   
 313   
 314  scalar d;
 315  set indices /1*6/;
 316   
 317  File TestingFile3 / TestingFile3.csv /;
 318  TestingFile3.pc=5;
 319  TestingFile3.nd=5;
 320  put TestingFile3;
 321  put 'Omega', put 'Tolerance', put 'Step Size Rule', put 'Iterations', put 'Converged?', put 'Gap LR', put 'Gap Naive', put 'Obj. Naive', put 'Obj. LR', put 'Gap' put 'Time Naive', put 'Time LR', put 'Final Lambda', put 'LB Heuristic' put /;
 322   
 323  ********************************************************************************
 324  * Solve main Problem
 325  ********************************************************************************
 326   
 327  start_time = jnow;
 328  solve schedule using MIP minimizing Obj ;
****                                          $257
**** LINE     39 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 257  Solve statement not checked because of previous errors
 329  end_time = jnow ;
 330   
 331   
 332   
 333  run_time_total = ghour(end_time - start_time)*3600 + gminute(end_time - start_time)*60 + gsecond(end_time - start_time);
 334   
 335  scalar ObjNaive;
 336  ObjNaive=Obj.l;
****               $141
**** LINE     47 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 337   
 338  scalar zlower;
 339  zlower=-Obj.l;
 340   
 341  scalar zupper;
 342  zupper=-schedule.objEst;
 343   
 344  scalar GapNaive;
 345  GapNaive = (zupper-zlower)/zupper;
 346   
 347  scalar ObjLR;
 348   
 349  scalar heuristic;
 350   
 351  scalar TimeNaive;
 352  TimeNaive=run_time_total;
 353   
 354  display Obj.l, run_time_total ;
 355   
 356  ********************************************************************************
 357  * Solve the Lagrangian Dual problem now
 358  ********************************************************************************
 359   
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\lp_lowerbound.gms
 361  start_time = jnow ;
 362  options optca=0 ;
 363  options optcr=0 ;
 364  solve schedule using RMIP minimizing OBJ ;
****                                           $257
**** LINE      4 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\lp_lowerbound.gms
**** LINE     71 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 257  Solve statement not checked because of previous errors
 365  end_time =jnow ;
 366  LP_time = ghour(end_time - start_time)*3600 + gminute(end_time - start_time)*60 + gsecond(end_time - start_time);
 367  init_lambda  = Const1_2.m ;
****                          $141
**** LINE      7 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\lp_lowerbound.gms
**** LINE     71 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 368  lowerbound   = Obj.l ;
 369  scalar LP_bound ;
 370  lambda       = init_lambda ;
 371  display init_lambda, LP_time, lowerbound    ;
 372  LP_bound   = Obj.l ;
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
 374  ********************************************************************************
 375  * Find a upperbound on the problem : a feasible solution
 376  ********************************************************************************
 377   
 378  *upperbound =  0;
 379  * Find a upper bound using a fixed value and solving MIP (a feasible solution)
 380  * solve single scenario problem and choose the worst #threshold problems
 381  start_time = jnow ;
 382  schedule_scenario.solvelink = 5 ;
 383  alias(rs,scen)
 384  parameter res_scenarios(rs,*) ;
 385   
 386  loop(rs,
 387  counter = ord(rs)  ;
 388  *Solving (2) for each scenario w with corresponding z(w) = 0
 389  solve schedule_scenario using MIP minimizing Obj ;
****                                                   $257
**** LINE     16 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
**** LINE     72 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 257  Solve statement not checked because of previous errors
 390  res_scenarios(rs,'obj') =obj.l ;
 391   
 392   
 393  res_scenarios(rs,'scenario') = counter ;
 394  *=counter
 395   
 396   
 397  );
 398  end_time =jnow ;
 399  run_time_total = ghour(end_time - start_time)*3600 + gminute(end_time - start_time)*60 + gsecond(end_time - start_time);
 400   
 401   
 402  ** Write to a file to sort
 403  FILE scen_sorted /scen_sorted.csv/;
 404  *.PC specifies the format of the put file: 5 -> Formatted output; non-numeric output is quoted and each item is delimited with commas.
 405  scen_sorted.PC = 5;
 406  *.ND sets the number of decimals that are displayed in the put file
 407  scen_sorted.ND = 3;
 408  PUT scen_sorted;
 409  loop(rs, put res_scenarios(rs,'scenario') put res_scenarios(rs,'obj') put /; ) ;
 410  PUTCLOSE scen_sorted;
 411   
 412   
 413  z.lo(scen) = scenario_sorted(scen,'value') ;
****                                          $116
**** LINE     40 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
**** LINE     72 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 116  Label is unknown
 414  *** Ensure file was generated correctly
 415  if ( sum(scen,z.lo(scen)) ne threshold, abort "sorted file not generated correctly check manually") ;
 416  start_time = jnow ;
 417  schedule.solprint = 0;
 418  *schedule.optfile  = 1;
 419  schedule.solvelink = 5 ;
 420  solve schedule using MIP minimizing Obj ;
****                                          $257
**** LINE     47 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
**** LINE     72 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 257  Solve statement not checked because of previous errors
 421  end_time = jnow ;
 422  bound_time =  run_time_total + ghour(end_time - start_time)*3600 + gminute(end_time - start_time)*60 + gsecond(end_time - start_time);
 423  upperbound = Obj.l ;
 424  prev_y(t) = y.l(t) ;
****                $141
**** LINE     51 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
**** LINE     72 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 425  *prev_w(scen,t) = w.l(scen,t) ;
 426   
 427  * Clear bound on z now
 428  z.up(scen) = 1 ;
 429  z.lo(scen) = 0 ;
 430   
 431  display lowerbound,upperbound,prev_y, LP_time, bound_time  ;
 432   
 433   
 434  parameter ldual_iter(iter) obj function at each iteration ;
 435  lr_time = 0 ;
 436   
 437  option limrow = 0, limcol = 0, optca=0.0001, optcr=0.0001, RESLIM   = 2100;
 438   
 439  prev_y(t) = y.l(t) ;
 440   
 441  parameter check(scen,t);
 442  scalar steprule;
 443  scalar FinalIter;
 444   
 445  loop(indices,
 446      option clear=results;
 447      noimprovement = 0;
 448      lambda=init_lambda;
 449      lowerbound=LP_bound;
 450      theta=originalTheta;
 451      lr_time=0;
 452      run_time_total=0;
 453      contin=1;
 454      steprule=ord(indices);
 455   
 456      loop(iter$contin,
 457      num_iter = ord(iter) ;
 458  *         pass a warm start
 459               y.l(t) = prev_y(t) ;
 460               z.l(scen) = scenario_sorted(scen,'value') ;
 461               start_time = jnow;
 462   
 463  *********************************************************************
 464  ***Solve a Lagrangian iteration
 465  *********************************************************************
 466   
 467  *Test
 468   
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\plain_lr.gms
 470  * Plain LR solve
 471  Lagrangian.solvelink = 5;
 472  Lagrangian.optfile   = 1;
 473  solve Lagrangian using mip minimizing bound_lr  ;
****                                                  $257
**** LINE      4 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\plain_lr.gms
**** LINE    109 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 257  Solve statement not checked because of previous errors
 474   
 475  bound             = bound_lr.l ;
****                               $141
**** LINE      6 INCLUDE     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\plain_lr.gms
**** LINE    109 INPUT       C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 476  prev_y(t)         = y.l(t) ;
 477  last_z(scen)      = z.l(scen) ;
 478   
 479  * if model is unbounded
 480  if (Lagrangian.modelstat =18,  bound = -100000000;  );
 481  results(iter,'status') = Lagrangian.modelstat;
 482   
 483      end_time = jnow ;
 484      results(iter,'time') = ghour(end_time - start_time)*3600 + gminute(end_time - start_time)*60 + gsecond(end_time - start_time);
 485      results(iter,'objective') = bound ;
 486   
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\LR_updates.gms
 488  *** UPDATES FOR LAMBDA, GAMMA, THETA
 489   
 490  * Gamma update
 491  gamma =  threshold - sum(scen, last_z(scen));
 492   
 493  * Bound and theta Update -> in stepsize 6
 494  if (bound > lowerbound,
 495           lowerbound = bound;
 496           noimprovement = 0;
 497  else
 498           noimprovement = noimprovement + 1;
 499           if (noimprovement > 1,  theta = theta/2; noimprovement = 0; );
 500  );
 501   
 502  * Fix the Stepsize
 503   
INCLUDE    C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\stepsizes.gms
 505  *** Guarantees that never zero in the denominator
 506  *norm = max(abs(gamma), 1e-6);
 507  norm2 = max(gamma*gamma, 1e-6);
 508   
 509  *** constant step-size rule
 510  if(steprule=1,stepsize =0.58;);
 511   
 512  *** constant step length
 513  if(steprule=2,stepsize = 200/norm2;);
 514   
 515  *** square summable but not summable
 516  if(steprule=3,stepsize =3/(2+num_iter););
 517   
 518  *** nonsummable diminishing
 519  if(steprule=4,stepsize= 1/sqrt(num_iter););
 520   
 521  *** nonsummable diminishing step length
 522  if(steprule=5,stepsize= (300/num_iter)/norm2;);
 523   
 524  *** original
 525  if(steprule=6,stepsize=theta*(upperbound - bound)/norm2;);
 526   
 527  * Lambda Update
 528   
 529  lambdaprevious = lambda ;
 530   
 531           if (gamma ge 0 and lambdaprevious eq 0,
 532                   lambda = lambdaprevious ; );
 533           if (gamma gt 0 and lambdaprevious gt 0,
 534                   lambda = lambdaprevious - min(stepsize, lambdaprevious/gamma)*gamma ; );
 535           if (gamma le 0,
 536                   lambda = lambdaprevious - stepsize*gamma; );
 537   
 538  * Check convergence
 539  convergence=0;
 540  deltalambda = abs(lambdaprevious-lambda) ;
 541  if( deltalambda < 0.0001, contin = 0; display 'lambdas same'; convergence = 1 );
 542   
 543  * Results output
 544  results(iter,'deltalambda') = deltalambda;
 545  results(iter,'noimprov') = noimprovement;
 546  results(iter,'theta') = theta;
 547  results(iter,'step') = stepsize;
 548  results(iter,'gamma') = gamma ;
 549  results(iter,'lambda') = lambda ;
 550  results(iter,'gap') = (((-lowerbound)+upperbound)/(-lowerbound))    ; //gap is same as computed by GAMS
 551      if( ((results(iter,'gap') < exit_tol) and (num_iter > 2)),convergence=2; contin = 0;);
 552      lr_time = lr_time + results(iter,'time')   ;
 553      if (lr_time > 2400, contin = 0 ; ) ;
 554   
 555      d=results(iter,'gap');
 556      FinalIter=num_iter;
 557  );
 558   
 559  run_time_total = LP_time + lr_time + bound_time  ;
 560   
 561  * check if any p and q active simultaneously (nothing to do with Lagrangian)
 562  *parameter check(scen,t);
 563   
 564   
 565  ObjLR=-lowerbound;
 566  heuristic=-upperbound;
 567   
 568  put TestingFile3;
 569  put n, put tol, put steprule, put FinalIter, put convergence, put d, put GapNaive, put zlower, put ObjLR, put ((ObjLR-max(heuristic,zlower))/ObjLR), put TimeNaive, put lr_time, put lambda, put heuristic put /;
 570   
 571  display results, lowerbound, upperbound, LP_bound, run_time_total, lr_time, num_iter ;
 572  display z.l, y.l ;
 573  display zlower, zupper, ObjLR, heuristic;
 574   
 575  );
 576   

**** LIST OF STRAY NAMES - CHECK DECLARATIONS FOR SPURIOUS COMMAS
**** STRAY NAME start_cost OF TYPE PARAM
**** STRAY NAME max_charge OF TYPE PARAM
**** STRAY NAME max_discharge OF TYPE PARAM
**** STRAY NAME init_bound OF TYPE PARAM
**** STRAY NAME t1 OF TYPE PARAM
**** STRAY NAME t2 OF TYPE PARAM

**** 14 ERROR(S)   0 WARNING(S)
GAMS 32.2.0  rc62c018 Released Aug 26, 2020 WEX-WEI x86 64bit/MS Windows - 10/07/21 16:00:27 Page 2
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
     2       19 INCLUDE        1      19  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\inputME.gms
     3       84 INCLUDE        2      65  ..C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\wind_costs.csv
     4      182 INCLUDE        1      20  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\subgradient_parameters.gms
     5      217 INCLUDE        1      22  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\equations_all.gms
     6      360 INCLUDE        1      71  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\lp_lowerbound.gms
     7      373 INCLUDE        1      72  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\heuristic_upperbound.gms
     8      469 INCLUDE        1     109  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\plain_lr.gms
     9      487 INCLUDE        1     115  .C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\LR_updates.gms
    10      504 INCLUDE        9      17  ..C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\stepsizes.gms


COMPILATION TIME     =        0.031 SECONDS      3 MB  32.2.0 rc62c018 WEX-WEI


USER: Small MUD - 5 User License                     S200323/0001AN-GEN
      Friedrich-Alexander-Universitaet Erlangen-Nurnberg         DC7699
      License for teaching and research at degree granting institutions


**** FILE SUMMARY

Input      C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.gms
Output     C:\Users\charl\OneDrive\Dokumente\A_Uni\HiWi\ArticleSubgradient\Code\OnlyImportantFiles\Naive_LR_solving.lst

**** USER ERROR(S) ENCOUNTERED
